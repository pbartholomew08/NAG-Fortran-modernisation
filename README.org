#+TITLE: NAG Fortran Modernisation Workshop
#+AUTHOR: Paul Bartholomew

#+LATEX_HEADER: \usepackage{fullpage}
#+LATEX_HEADER: \hypersetup{colorlinks}

* Introduction

** Good practice - code structure

- Modularise code
- Write code so that it can be tested
- Use ~implicit none~ - all variables have to be /explicitly defined/
- Use whitespace to make your code readable for others and for yourself
- Use /consistent/ formatting
- Agree on a formatting standard for your team so that you can read each other's code in a
  consistent manner

*** Coding style suggestions 

These are suggestions, not rules, to think about

- Use lower case (mostly)
- Capitalise first character of subroutines and functions, use spaces around arguments
- Lower case arrays, no spaces around indices (enables visual differentiation of function calls and
  arrays)
- Use square brackets to define arrays and use a digit on each side of the decimal point /i.e./
#+BEGIN_SRC f90
  A = [ 0.0 1.0 2.0 ]
#+END_SRC
- Use spaces around mathematical operators
- *Remember that Fortran is column-major* for memory access
- Capitalise names of constants /i.e./
#+BEGIN_SRC f90
  integer, parameter :: MAX_CELLS = 1000
#+END_SRC
- Comment beginning of files with
  - purpose of code. Include LaTeX code of equation
  - 
- Use names that are meaningful to your scientific discipline
- For functions/procedures use verbs /e.g./ ~get_index(a, 1)~
- In functions and subroutines use the ~intent~ keyword
- If using subroutines from third-party libraries, capitalise the name /e.g./ ~MPI_INIT(ierr)~
- =Fortran= *does not short-circuit* ~if~ statements so
#+BEGIN_SRC f90
  if (size(vec) == 10 .and. vec(10) > eps) then
     !! Do something
  endif
#+END_SRC
should be written as
#+BEGIN_SRC f90
  if (size(vec) == 10) then
     if (vec(10) > eps) then
        !! Do something
     endif
  endif
#+END_SRC
to prevent potential =segfaults= if ~vec~ is smaller than 10.
- Indicate array operations using brackets and colons /e.g./ ~a(:) = b(:) + c(:)~ rather than ~a = b + c~
- Array operations are more likely to be vectorised than their loop equivalents
- Look into array masking, this allows you to apply array operation only where the values in the
  array meet some condition
- ~block~ statements can be used as a modern version of ~goto~'s

*** Gauss-Seidel method                                           :example:

Can be written in both ~loop~ and array versions

** Fortran modules

=Fortran= modules allow type checking for function/subroutine arguments at compile time.
You can rename entities from modules:
#+BEGIN_SRC f90
    use module_mod, solve_system => solve_linear_system
#+END_SRC
to prevent name clashes for example.
Modules also allow us to implement basic polymorphism by defining an ~interface~ to type-specialised
subroutines.

*** Submodules

These are introduced by =Fortran 2008=, supported by =ifort >v16= and =gfortran >v6=, this allows you to
separate the /implementation/ from the /interface/ and can allow more efficient compilation.
The =module= defines the /interface/ whilst the =submodule= contains the /implementation/, thus a change of
implementation only requires compilation of the submodule followed by re-linking of object files.


** Fortran loops

- Always use =do= loops with fixed bounds, without ~cycle~ or ~exit~ statements which could prevent
  vectorisation
- Avoid branching in loops!
- Avoid =do while= loops
- ~forall~ (obsoleted in =Fortran 2018=) and ~do concurrent~ (=Fortran 2008=?) allow us to tell the compiler
  that there are no data dependencies - easier for compiler to optimise
  - ~do concurrent~ allows for masking
  - ~do concurrent~ allows variables to be declared ~local~ for example, similar to =openMP=, with aim of
    improving performance

** IEEE floating point arithmetic

=Fortran 2003= provides ways to check for =IEEE= exceptions in code (although can also use
~-ffpe-trap=all~ or equivalent on compile flags).

** API design

- Should provide a high-level description of the behaviour of the code
- Provides the building blocks of an application
- Has a long life - requires careful design
- Should be easy to use, difficult to misuse - always use ~intent~ keyword

*** Optional arguments

Allows extending =API= without requiring changes to existing code.

*** Pure procedures

Allows you to indicate that a procedure does not have side-effects, /i.e./ does not change values of
arguments.

*** Elemental procedures

Can be applied to scalar /or/ array arguments, have the same properties as ~pure~ procedures.
In particular this allows for vectorising operations on arrays.

* Supplementary information

Supplementary information is available at:
[[https://www.nag.co.uk/content/fortran-modernization-workshop]].
